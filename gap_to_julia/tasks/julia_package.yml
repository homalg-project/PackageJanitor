- name: Set package variables for {{ package.name }}
  set_fact:
    package_name: "{{ package.name }}"
    package_description: "{{ package.description | default('') }}"
    target_path: "{{ lookup('env', 'HOME') }}/.julia/dev/{{ package.target }}"
    package_url: "{{ '' if package.source == '' else (package.source ~ '/') }}{{ package.name }}"
    source_package_path: "{{ lookup('env', 'HOME') }}/.gap/pkg/{{ '' if package.source == '' else (package.source ~ '/') }}{{ package.name }}"
    target_package_path: "{{ lookup('env', 'HOME') }}/.julia/dev/{{ package.target }}/{{ package.name }}"
    package_version: "{{ package.version | default('0.1.0') }}"
    julia_version: "{{ package.julia_version | default('1.11') }}"
    dependencies: "{{ package.dependencies | default([], true) }}"
    weak_dependencies: "{{ package.weak_dependencies | default([], true) }}"
    extras: "{{ package.extras | default([], true) }}"
    targets: "{{ package.targets | default({'test': 'default'}) }}"
    test_imports: "{{ package.test_imports | default([], true) }}"
    test_upto_whitespaces: "{{ package.test_upto_whitespaces | default(false) }}"
    extensions: "{{ package.extensions | default({}) }}"
    import_dependencies: "{{ package.import_dependencies | default(true) }}"
    pre_init_file_exists: "{{ package.pre_init_file_exists | default(false) }}"
    post_init_file_exists: "{{ package.post_init_file_exists | default(false) }}"
    disable_method_overwrite_warning: "{{ package.disable_method_overwrite_warning | default(false) }}"
    cleanup_test_files_by_keywords: "{{ package.cleanup_test_files_by_keywords | default([], true) }}"
    playbook_dir_relative_to_home: "{{ playbook_dir | relpath(ansible_env.HOME) }}"
    gen_full: "{{ gen_full | default('1') }}"

- name: Verify the GAP package {{ package_name }} exists
  stat:
    path: "{{ source_package_path }}"
  register: gap_package_directory_exists

- name: Package not found at {{ source_package_path }}, fallback to ~/.gap/pkg/{{ package_name }}
  set_fact:
    source_package_path: "{{ lookup('env', 'HOME') }}/.gap/pkg/{{ package_name }}"
  when: not gap_package_directory_exists.stat.exists

- name: Run `make doc` in {{ source_package_path }} to update documentation
  command: make doc
  args:
    chdir: '{{ source_package_path }}'
  register: makedoc_result
  changed_when: false

- name: Verify the Julia package target path exists
  stat:
    path: "{{ target_path }}"
  register: target_path_exists
  when: gen_full == '1'

- name: Fail if the parent directory of the Julia package does not exist
  fail:
    msg: "The parent directory '{{ target_path }}' does not exist!"
  when: gen_full == '1' and not target_path_exists.stat.exists

- name: Check whether the Julia package directory already exists
  stat:
    path: '{{ target_package_path }}'
  register: package_directory_exists
  when: gen_full == '1'

- name: Generate Julia package using `Pkg.generate` if it does not exist
  command: >
    julia -e "using Pkg; Pkg.generate(\"{{ package_name }}\")"
  args:
    chdir: '{{ target_path }}'
  when: gen_full == '1' and package_directory_exists.stat.exists == false
  register: generate_julia_package

- name: Add src/{{ package_name }}.jl
  template:
    src: package.jl.j2
    dest: "{{ target_package_path }}/src/{{ package_name }}.jl"
    mode: '0644'
  when: gen_full == '1'

- name: Add Makefile
  template:
    src: makefile.j2
    dest: "{{ target_package_path }}/makefile"
    mode: '0644'
  when: gen_full == '1'

- name: Add .generate.sh
  template:
    src: generate.j2
    dest: "{{ target_package_path }}/.generate.sh"
    mode: '0755'
  when: gen_full == '1'

- name: Extract package authors
  shell: |
    paste \
      <(grep -RI FirstNames PackageInfo.g | cut -d '"' -f 2) \
      <(grep -RI LastName PackageInfo.g | cut -d '"' -f 2) \
      <(grep -RI Email PackageInfo.g | cut -d '"' -f 2) \
    | awk '{print "\t\""$1" "$2" <"$3">\""}'
  args:
    chdir: '{{ source_package_path }}'
    executable: /bin/bash
  register: authors
  when: gen_full == '1'
  changed_when: false

- name: Extract the package subtitle
  shell: |
    grep '^Subtitle := ' "PackageInfo.g" | cut -d '"' -f 2
  args:
    chdir: '{{ source_package_path }}'
  register: subtitle
  when: gen_full == '1'
  changed_when: false

- name: Extract the GAP-package version
  shell: |
    grep '^Version := ' "PackageInfo.g" | cut -d '"' -f 2
  args:
    chdir: "{{ source_package_path }}"
  when: gen_full == '1'
  register: package_version_in_gap
  changed_when: false

- name: Extract UUIDs of dependencies, weak dependencies, and extras
  shell: |
    deps="{{ dependencies_names | join(" ") }}"
    weak="{{ weak_dependencies_names | join(" ") }}"
    extras="{{ extras_names | join(" ") }}"

    # helper: extract a group of names
    extract_group() {
      group="$1"
      out=""
      for pkg in $group; do
        line=$(grep "^$pkg " ./files/UUIDs || true)
        if [ -n "$line" ]; then
          # package found in UUIDs file → extract UUID
          if [ -n "$out" ]; then
            out="$out\n$line"
          else
            out="$line"
          fi
        else
          # package not found → add warning line
          missing="$pkg = \"Please run 'using Pkg; only(keys(filter(p -> p.second.name == \"$pkg\", Pkg.dependencies())))' and add it to 'PackageJanitor/gap_to_julia/files/UUIDs'\""
          if [ -n "$out" ]; then
            out="$out\n$missing"
          else
            out="$missing"
          fi
        fi
      done
      printf "$out"
    }

    deps_out=$(extract_group "$deps")
    weak_out=$(extract_group "$weak")
    extras_out=$(extract_group "$extras")

    # concatenate groups with &
    printf "%b&%b&%b\n" "$deps_out" "$weak_out" "$extras_out"
  args:
    chdir: "{{ playbook_dir }}"
  register: uuids
  changed_when: false
  vars:
    dependencies_names: "{{ dependencies }}"
    weak_dependencies_names: "{{ weak_dependencies }}"
    extras_names: "{{ extras }}"
  when: gen_full == '1'

- name: Extract the UUID from Project.toml if it exists
  shell: |
    if [ -f Project.toml ]; then
      grep '^uuid =' Project.toml | cut -d '"' -f 2
    else
      julia -e 'using UUIDs; println(string(UUIDs.uuid4())); flush(stdout)'
    fi
  args:
    chdir: "{{ target_package_path }}"
  when: gen_full == '1'
  register: package_uuid
  changed_when: false

- name: Extract the current version from Project.toml if it exists
  shell: |
    if [ -f Project.toml ]; then
      grep '^version =' Project.toml | cut -d '"' -f 2
    else
      echo "0.1.0"
    fi
  args:
    chdir: "{{ target_package_path }}"
  when: gen_full == '1'
  register: current_version
  changed_when: false

- name: Extract compats from the existing Project.toml if it exists
  shell: |
    if [ -f Project.toml ]; then
      awk '/^\[compat\]/ {flag=1; next} /^\[/{flag=0} flag {print}' Project.toml
    else
      echo "# Here you can specify the compatibility versions"
    fi
  args:
    chdir: "{{ target_package_path }}"
  when: gen_full == '1'
  register: compat_section
  changed_when: false

- name: Add Project.toml
  template:
    src: Project.toml.j2
    dest: "{{ target_package_path }}/Project.toml"
    mode: '0644'
  vars:
    uuids_list: "{{ uuids.stdout.split('&') }}"
    package_authors: "{{ authors.stdout_lines }}"
  when: gen_full == '1'

- name: Add README.md
  template:
    src: README.md.j2
    dest: "{{ target_package_path }}/README.md"
    mode: '0644'
  vars:
    package_subtitle: "{{ subtitle.stdout }}"
  when: gen_full == '1'

- name: Make sure /src/gap, /docs/src and /test exist
  file:
    path: "{{ item }}"
    state: directory
    mode: '0755'
  with_items:
    - "{{ target_package_path }}/src"
    - "{{ target_package_path }}/src/gap"
    - "{{ target_package_path }}/docs"
    - "{{ target_package_path }}/docs/src"
    - "{{ target_package_path }}/test"
  when: gen_full == '1'

- name: List all subdirectories in /gap
  find:
    paths: '{{ source_package_path }}/gap'
    file_type: directory
  register: gap_subdirs
  when: gen_full == '1'

- name: Make sure subdirectories of {{ package_name }}/gap/ exist in the Julia package
  file:
    path: "{{ target_package_path }}/src/gap/{{ item.path | basename }}"
    state: directory
  loop: '{{ gap_subdirs.files }}'
  when: gen_full == '1'

- name: Add test/runtests.jl
  template:
    src: runtests.jl.j2
    dest: "{{ target_package_path }}/test/runtests.jl"
    mode: '0644'
  when: gen_full == '1'

- name: Make sure .github/workflows exist in the Julia package
  file:
    path: "{{ target_package_path }}/.github/workflows"
    state: directory
    mode: '0775'
  when: gen_full == '1'

- name: Add LICENSE, .gitignore, TagBot.yml, and src/init.jl
  copy:
    src: "{{ item.src }}"
    dest: "{{ target_package_path }}/{{ item.dest }}"
    mode: '0644'
  when: gen_full == '1'
  loop:
    - { src: LICENSE, dest: LICENSE }
    - { src: gitignore, dest: .gitignore }
    - { src: TagBot.yml, dest: .github/workflows/TagBot.yml }
    - { src: init.jl, dest: src/init.jl }

- name: Copy read.g and init.g to /src
  copy:
    src: '{{ source_package_path }}/{{ item }}'
    dest: '{{ target_package_path }}/src/{{ item }}'
    mode: '0644'
  with_items:
    - read.g
    - init.g
  when: gen_full == '1'
  changed_when: false

- name: Modify read.g and init.g in-place and rename them to .autogen.jl
  shell: |
    for f in read.g init.g; do
      sed -i \
        -e 's/#% G2J:julia-only //g' \
        -e 's/ReadPackage/include/g' \
        -e 's/"{{ package_name }}"\s*,\s*//g' \
        -e 's/\.g\([di]\)"/.g\1.autogen.jl"/g' \
        "$f"
      mv "$f" "$f.autogen.jl"
    done
  args:
    chdir: '{{ target_package_path }}/src'
  when: gen_full == '1'
  changed_when: false

- name: Transpile the GAP-code to Julia-code
  shell: 'PKG_NAME="{{ package_name }}" USING="{{ test_imports | join(", ") }}" {{ playbook_dir }}/files/transpile_gap_to_julia {{ package_name }}'
  args:
    executable: /bin/bash
  register: transpile_result

- name: Remove AutoDocTest fragments containing keywords safely
  shell: |
    printf "%s\n" {{ cleanup_test_files_by_keywords | map('quote') | join(' ') }} | while IFS= read -r kw; do
      grep -l -- "$kw" *.tst.autogen.md 2>/dev/null | xargs -r rm -f
    done
  args:
    chdir: '{{ target_package_path }}/docs/src'
  when: cleanup_test_files_by_keywords | length > 0
  changed_when: false

- name: Merge AutoDocTest fragments into AutoDocTests.tst.autogen.md and remove fragments
  shell: |
    set -- {{ package_name | lower }}*.tst.autogen.md
    if [ -e "$1" ]; then
      # merge AutoDocTests into one big testfile to execute in the correct order
      cat {{ package_name | lower }}*.tst.autogen.md > AutoDocTests.tst.autogen.md
      rm -f {{ package_name | lower }}*.tst.autogen.md
      # execute tests in the same session
      sed -i 's/```jldoctest/```jldoctest AutoDocTests/g' AutoDocTests.tst.autogen.md
    fi
  args:
    chdir: '{{ target_package_path }}/docs/src'

- name: Display success message
  debug:
    msg: "Julia package '{{ package_name }}' created/updated in '{{ target_path }}'"
